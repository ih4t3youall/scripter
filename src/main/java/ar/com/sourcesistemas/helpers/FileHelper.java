package ar.com.sourcesistemas.helpers;

import javax.swing.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class FileHelper {

    private String basePath;
    private String actualPath;
    private String bashrc;
    private String fileName;

    public FileHelper(){
         this.basePath = System.getProperty("user.home")+"/.scripts/";
         this.actualPath = "";
         this.bashrc = System.getProperty("user.home")+"/.zshrc";
         this.fileName = "";
    }

    public void setBashrc(String newBashrc){
        this.bashrc = System.getProperty("user.home")+"/"+newBashrc;
    }

    private boolean fileExists(String filePath){
        return new File(filePath).exists();
    }

    public boolean createFolderIfNotExists(String folderName){

        this.actualPath = this.basePath+folderName+"/";
        if (this.fileExists(actualPath)){
            return true;
        }else{
            return new File(actualPath).mkdir();
        }
    }

    public void createFileIfNotExists(String fileName) throws IOException {
        String tempPath = this.actualPath+fileName;
        this.fileName = fileName;
        if (fileExists(tempPath)){
            Files.delete(Paths.get(tempPath));
        }
        Files.createFile(Paths.get(tempPath));
    }


    public String getAbsoluteWritePath(String fileName){
        return this.actualPath+"/"+fileName;
    }
    public File[] getFoldersNames(){
        FileFilter fileFilter = pathname -> Files.isDirectory(Paths.get(pathname.getPath()));
        File[] list = new File(basePath).listFiles(fileFilter);
        return list;
    }


    public  void createFolderPrompt(){
        String folderName = "";
        while(true) {
            folderName = JOptionPane.showInputDialog(null, "Folder name:");
            //si tiene espacio lo muestra de nuevo, sino sigue
            if (folderName.indexOf(" ") == -1) {
                break;
            }
        }

        if (folderName != null ){
            this.createFolderIfNotExists(folderName);
        }
        else{
            System.out.println(" el folder name esta vacio");
            System.exit(2);
        }
    }

    public String getFilePath(){
        if (fileName != "" && actualPath != "")
        {
            return this.actualPath+fileName;
        }
        return null;
    }

    public List<String> getBashRcFile(){
        List<String> arrayList = new ArrayList<>();
        try (Stream<String> stream = Files.lines(Paths.get(bashrc))) {
            stream.forEach(x->arrayList.add(x));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return arrayList;
    }

    public String getBashRc(){
        return this.bashrc;
    }

    public boolean removeBashrc() {
        try {
            Files.deleteIfExists(Paths.get(this.bashrc));
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public boolean addAlias(List<String> bashrc, String filePath, String fileName, String command){
        int cont = 0;

        int index = fileName.indexOf(".");
        if(index != -1)
            fileName = fileName.substring(0,index);

        boolean find = false;
        for(int i =0 ; i<bashrc.size(); i++){
            if (bashrc.get(i).indexOf("#autogenerated code") == 0){
                find = true;
                break;
            }
            cont++;
        }
        String newAlias = createAlias(command,fileName,filePath);
        if (!find){
            bashrc.add("#autogenerated code");
            bashrc.add(newAlias.toString());
        }else {
            bashrc.add(cont+1, newAlias.toString());
        }

        boolean wasDeleted = removeBashrc();
        if (!wasDeleted)
            System.exit(1);

        writeBashrc(bashrc);
        return true;

    }


    private String createAlias(String command,String fileName,String filePath){
        StringBuilder newAlias = new StringBuilder();
        newAlias.append("alias");
        newAlias.append(" ");
        newAlias.append(fileName);
        newAlias.append("=");
        newAlias.append("\"");
        newAlias.append(command);
        if (filePath != "") {
            newAlias.append(" ");
            newAlias.append(filePath);
        }
        newAlias.append("\"");

        return newAlias.toString();
    }

    public void writeBashrc(List<String> bashrcList) {

        try {
            Files.write(Paths.get(this.bashrc), bashrcList);
        } catch (IOException e) {
            System.out.println("Write fail, here is a back up of how the file should be");
            bashrcList.forEach(System.out::println);
            e.printStackTrace();
        }
    }

    public List<String> readCreateConfigFile() throws IOException {
        String tempFolderPath = this.basePath+"javaApps/";
        String tempFilePath = this.basePath+"javaApps/"+"scripter/configFile";
        boolean folderExists = Files.exists(Path.of(tempFolderPath));
        boolean fileExists = Files.exists(Path.of(tempFilePath));
        if (!folderExists)
            System.exit(3);

        if (!fileExists){
            Files.createFile(Path.of(tempFilePath));
        }
        List<String> strings = Files.readAllLines(Path.of(tempFilePath));
        for (String string : strings)
            System.out.println(string);
        return strings;



    }

    public void writeCreateConfigFile(List<String> configs) throws IOException {
        String tempFilePath = this.basePath+"javaApps/"+"scripter/configFile";

        try (FileWriter writer = new FileWriter(tempFilePath); BufferedWriter bw = new BufferedWriter(writer)) {

            for (String config : configs)
                bw.write(config);

        } catch (IOException e) {
            System.err.format("IOException: %s%n", e);
        }
    }

    public void setFolder(String folderName) {
        this.actualPath = this.basePath+folderName+"/";
    }
}
